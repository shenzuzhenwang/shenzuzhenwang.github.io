<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022计算机保研经验</title>
      <link href="/2023-02-07-2022-ji-suan-ji-bao-yan-jing-yan/"/>
      <url>/2023-02-07-2022-ji-suan-ji-bao-yan-jing-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、个人水平"><a href="#一、个人水平" class="headerlink" title="一、个人水平"></a>一、个人水平</h2><ul><li>本科：西北某末流酒吧舞</li><li>专业：计算机学院 计算机科学与技术</li><li>Rank：综排前5%（专业约200人）</li><li>英语：CET-4、CET-6均擦线（不到470）</li><li>科研：无</li><li>竞赛：机器人相关水赛若干 + PPT竞赛若干（国奖省奖都有）</li><li>研究意向：尽量不去 AI，拒绝 CV，偏向一些计算机底层领域</li><li>学位偏好：有点读博的打算，偏向学硕，学校够好老师不烂直博也行</li></ul><h2 id="二、保研tips（主观）"><a href="#二、保研tips（主观）" class="headerlink" title="二、保研tips（主观）"></a>二、保研tips（主观）</h2><ul><li><strong>计算机保研交流群</strong>（绿群）： 605176069（一群）、943826679（二群）</li><li>靠前的大学的预推免不一定比夏令营简单，因为坑被占完了或者压根没有，就算有大部分也是剩下的烂坑（当然有些学校就爱预推免收人，dddd）</li><li>纯个人经验：我所有学校提交的排名均为综排（让提交成绩排名的学校我也交的综排），而且除了清北都没有被卡</li><li><strong>CET 6</strong>：其实过了就行，我看到的只有两所学校夏令营卡成绩，感觉就是初筛才看，后面就看笔试面试表现了，反正我的擦线成绩感觉没咋拖后腿</li><li><strong>机试</strong>：不是所有学校有，但很多都有，而且有的学校只让用C/C++</li><li>CCF - CSP：非必须，有算法基础的争取刷个300+（北航要C/C++不要ALL），没有基础和兴趣的还是算了，考一次还是挺贵的（周围很多高Rank大佬都没有，有的成绩大部分也不高）</li><li>提前陶瓷：本人没有干过，但除了清北以外也都让入营了，故个人斗胆认为陶瓷和入营关系不大（当然假如非常喜欢某老师还是应该套）</li><li>计算机系统能力大赛：<strong>超有含金量的竞赛</strong>（个人认为同等级下难度与含金量不小于ACM），我知道的有人保研清北计算所，这个比赛给他们加了不少分</li><li><strong>鸽子与海王</strong>：个人提倡大家尽量别当，拿来保底的、大概率不去的 offer 就尽量别联系老师了。（23年线下的话可能会好点）</li></ul><h2 id="三、夏令营（全投硕士）"><a href="#三、夏令营（全投硕士）" class="headerlink" title="三、夏令营（全投硕士）"></a>三、夏令营（全投硕士）</h2><table><thead><tr><th align="left">学院</th><th align="left">入营情况</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">复旦大学工程与应用技术研究院</td><td align="left">√</td><td align="left">优营，后鸽</td></tr><tr><td align="left">同济大学电院计算机系</td><td align="left">√</td><td align="left">≈优营，后鸽</td></tr><tr><td align="left">上海交通大学软件学院</td><td align="left">√</td><td align="left">机试完鸽了</td></tr><tr><td align="left">南京大学计算机科学与技术系</td><td align="left">√</td><td align="left">候补（其实算被刷了）</td></tr><tr><td align="left">中国科学院软件所</td><td align="left">√</td><td align="left">入营鸽</td></tr><tr><td align="left">中国科学技术大学计算机科学与技术学院</td><td align="left">√</td><td align="left">最终offer</td></tr><tr><td align="left">浙江大学软件学院</td><td align="left">√</td><td align="left">超级大海王，鸽</td></tr><tr><td align="left">华中科技大学国光</td><td align="left">√</td><td align="left">没必要投的，反思</td></tr><tr><td align="left">西安交通大学计算机学院</td><td align="left">√</td><td align="left">也不该投</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">哈尔滨工业大学（深圳）计算机学院</td><td align="left">×</td><td align="left">bar比华五都高（流汗黄豆）</td></tr><tr><td align="left">中国科学院计算技术研究所</td><td align="left">×</td><td align="left">计算所bar好高</td></tr><tr><td align="left">北京大学软件与微电子学院</td><td align="left">×</td><td align="left">软微今年bar巨高</td></tr></tbody></table><h3 id="1-复旦大学工程与应用技术研究院（智能机器人研究院）"><a href="#1-复旦大学工程与应用技术研究院（智能机器人研究院）" class="headerlink" title="1. 复旦大学工程与应用技术研究院（智能机器人研究院）"></a>1. 复旦大学工程与应用技术研究院（智能机器人研究院）</h3><p>特点：计算机人上人，只有是0812，即学硕与直博，没有专硕（对比隔壁机械只有专硕，不用考虑校外租房）</p><p>考核：今年只有面试</p><p>面试内容为英文自我介绍+英文问答+计算机基础知识，15min，其中计算机基础知识并非408，是一部分计算机底层知识或计算机常识，也没办法复习，凭个人平日积累吧</p><p>个人觉得面试得还不错，优营</p><p>但是最后选导师时，发现导师的方向都不算太喜欢，比较强的zwq、zlh没名额了，就没有联系导师当保底了，最后鸽。</p><p>此外教务老师人非常好，还说可以帮忙联系导师，但最后好像还是被鸽穿了（年年如此）</p><p>评价：<strong>非常推荐</strong>，9月底有概率捡漏强导</p><p><strong>自测工研院优营后鸽，预推免没法再报计院，不知道是不是个人问题</strong></p><h3 id="2-同济大学电子与信息工程学院计算机科学与技术系"><a href="#2-同济大学电子与信息工程学院计算机科学与技术系" class="headerlink" title="2. 同济大学电子与信息工程学院计算机科学与技术系"></a>2. 同济大学电子与信息工程学院计算机科学与技术系</h3><p>特点：好像有oq，不要Rank 1%，而且考核比较正式</p><p>考核：我见过的唯一一个 笔试+机试+面试</p><p>笔试非常正规，内容为408+英文文献翻译，我大概会一半多（剩下全还给老师了）</p><p>机试我称之为小模拟，类似于实现某个算法并应用，不算太难，三道题，我自测应该全过，不过值得吐槽的是他们没有在线OJ</p><p>面试为英文问答+专业知识+政治，不知道为啥，大部分都是政治，类似于老师push怎么办，我还以为寄了</p><p>成绩一出，排在中游，感觉还行，但已经有复旦优营了，鸽</p><p>评价：考核很正式，但用惯了在线OJ，机试有点不适应</p><h3 id="3-上海交通大学软件学院"><a href="#3-上海交通大学软件学院" class="headerlink" title="3. 上海交通大学软件学院"></a>3. 上海交通大学软件学院</h3><p>特点：<strong>IPADS</strong>实验室超强，但软院有四五个方向，我没选IPADS，怕太卷</p><p>考核：机试+面试</p><p>机试为大模拟，模拟一个决策树，并且还贴心的将每个步骤拆开，我每做完一步都检查一下，最后一步没来得及完成，但这是我编码最舒服的一次</p><p>面试需要读论文，对方向不满意+没时间读+与南大冲突，遂鸽</p><p>值得一提，宣讲里说学硕极少，大部分都是专硕，名额不多，其中本校占了很大一部分，而且有些方向专硕可能会去嘉兴（甚至贵州），加上上交专硕没宿舍</p><p>评价：老师人很好，很诚实。方向只有IPADS比较好，据说隔壁院有人捡漏了，羡慕</p><h3 id="4-南京大学计算机科学与技术系"><a href="#4-南京大学计算机科学与技术系" class="headerlink" title="4. 南京大学计算机科学与技术系"></a>4. 南京大学计算机科学与技术系</h3><p>特点：初审好像不筛人，通过笔试筛人</p><p>考核：笔试+面试（硬核）</p><p>笔试只有选择题，但依旧非常难，做过的都知道，感觉一大半都是蒙的</p><p>面试更硬核，上来英文解释专业名词，把大脑CPU干炸了（中文我都不会解释），总之就是大寄特寄</p><p>排到了wl里，但到了928也没动静。</p><p>评价：南大太硬核了，我唯一一个疯狂道歉的夏令营</p><h3 id="5-中国科学技术大学计算机科学与技术学院"><a href="#5-中国科学技术大学计算机科学与技术学院" class="headerlink" title="5. 中国科学技术大学计算机科学与技术学院"></a>5. 中国科学技术大学计算机科学与技术学院</h3><p>特点：没有预推免，没有直博</p><p>考核： 面试</p><p>面试是PPT自我介绍+英文问答+专业知识+项目介绍，大部分时间都在自我介绍和问项目。</p><p>面试合格后需要有老师接收才行</p><p>拿了优营后，通过同学推荐（感谢）+个人喜好，联系了一个课题组，最后老师同意留个名额给我</p><p>评价：中科大培养方式非常好，只有硕士，读博需要转博，<strong>入营送奖品</strong></p><h3 id="6-其余大学"><a href="#6-其余大学" class="headerlink" title="6. 其余大学"></a>6. 其余大学</h3><p>华科国光确实不该报，有点海，反思</p><p>西交计院夏令营不发优营，放了我校一堆人进来，最后一个没去</p><p>计算所好像卡我们学校前三，没几个人入营，预推免好像挺好入的，但好像大部分都是专硕</p><p>倒是自所我们学校入了一堆控制的，而且拿优营的不少</p><p>软微今年bar挺高，我们学校夏令营就入了一个，预推免还有个捡漏的，但好像方向emmm</p><p>哈深最值得吐槽，比华五bar都高，活该被鸽</p><h2 id="四、预推免"><a href="#四、预推免" class="headerlink" title="四、预推免"></a>四、预推免</h2><p>夏令营已经有了一个比较满意的offer了，故预推免随缘投，仅准备投清北</p><p>清华竟然入了贵系，北大没有回音</p><h3 id="清华贵系"><a href="#清华贵系" class="headerlink" title="清华贵系"></a>清华贵系</h3><p>完全是出乎意料，但也觉得不太可能从大佬手中抢到名额，遂摆烂</p><p>考核：机试+面试</p><p>清贵的机试超难，三道题，感觉差不多是CSP后三题的水平，题型也像。我抱着玩的心态怒怼大模拟四个多小时，遂寄</p><p>面试没脸参加</p><h2 id="五、写在最后"><a href="#五、写在最后" class="headerlink" title="五、写在最后"></a>五、写在最后</h2><ul><li>感谢每一位陪我走完保研路的朋友，愿今后继续互利共勉</li><li>祝愿每一位保研人最终都能够有理想的去处！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鼠鼠管理系统</title>
      <link href="/2023-01-12-shu-shu-guan-li-xi-tong/"/>
      <url>/2023-01-12-shu-shu-guan-li-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="鼠鼠管理系统"><a href="#鼠鼠管理系统" class="headerlink" title="鼠鼠管理系统"></a>鼠鼠管理系统</h1><h2 id="一、软件框架"><a href="#一、软件框架" class="headerlink" title="一、软件框架"></a>一、软件框架</h2><p>本工具以Qt5.14为基本框架，经过多次试验，并未发现明显问题。</p><p>本工具主要语言为C++，编译器为minGW，build工具为gmake，使用Qt官方IDE即Qt Creator。</p><h2 id="二、模块描述"><a href="#二、模块描述" class="headerlink" title="二、模块描述"></a>二、模块描述</h2><h3 id="1-主界面模块"><a href="#1-主界面模块" class="headerlink" title="1. 主界面模块"></a>1. 主界面模块</h3><p>主界面模块包括多个子界面：</p><p>小鼠信息界面，可以在表格上直接查看小鼠的各项信息，并且可以通过点击，进入小鼠信息模块；</p><p>查询界面，可以通过名称、出生日期、最后喂养时间、健康状态和负责人来查询特定的小鼠；</p><p>死亡列表界面，可以在表格上直接查看死亡小鼠的各项信息，并且可以直接在表格上进行修改；</p><p>喂食记录页面，可以在表格上直接查看喂食的记录，并且可以直接在表格上进行修改；</p><p>登录记录页面，可以查看用户的登录记录，并且可以直接在表格上进行修改；</p><p>用户信息界面，可以查看所有用户的各项信息，并且可以直接在表格上进行修改</p><h3 id="2-小鼠信息模块"><a href="#2-小鼠信息模块" class="headerlink" title="2. 小鼠信息模块"></a>2. 小鼠信息模块</h3><p>显示ID号、名称、描述、健康程度、负责人、出生日期和死亡日期，并且具有喂食、出生、死亡、修改信息等功能。</p><h3 id="3-数据库连接模块"><a href="#3-数据库连接模块" class="headerlink" title="3. 数据库连接模块"></a>3. 数据库连接模块</h3><p>总共创建了三个连接：normal、senior、admin，根据登录用户的不同权限，来选择使用对应的连接。</p><h3 id="4-登录模块"><a href="#4-登录模块" class="headerlink" title="4. 登录模块"></a>4. 登录模块</h3><p>通过在登录界面上输入用户名与密码，然后在数据库中进行查询，最后根据是否查询正确，与权限等级，来进行登录。</p><h3 id="5-注册模块"><a href="#5-注册模块" class="headerlink" title="5. 注册模块"></a>5. 注册模块</h3><p>通过在注册输入各项信息：用户名、密码、地址、手机号、电话号等信息，完成注册，并将信息保存至数据库中。</p><h3 id="6-帮助模块"><a href="#6-帮助模块" class="headerlink" title="6. 帮助模块"></a>6. 帮助模块</h3><p>在帮助界面上，可以查看到详细的使用方法，用于初次使用本系统的用户。</p>]]></content>
      
      
      <categories>
          
          <category> 管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Qt </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C++11实现SysY语言简单编译器</title>
      <link href="/2022-12-11-shi-yong-c-11-shi-xian-sysy-yu-yan-jian-dan-bian-yi-qi/"/>
      <url>/2022-12-11-shi-yong-c-11-shi-xian-sysy-yu-yan-jian-dan-bian-yi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="使用C-11实现SysY语言简单编译器"><a href="#使用C-11实现SysY语言简单编译器" class="headerlink" title="使用C++11实现SysY语言简单编译器"></a>使用C++11实现SysY语言简单编译器</h1><p>github: <a href="https://github.com/shenzuzhenwang/Complier-SysY">https://github.com/shenzuzhenwang/Complier-SysY</a></p><h2 id="一、整体简介"><a href="#一、整体简介" class="headerlink" title="一、整体简介"></a>一、整体简介</h2><p>使用架构：arm7ve</p><p>实现语言：C++</p><p>测试样例：SysY 2021，功能样例。全部通过</p><p> SysY 2021，性能样例。部分性能优化极大</p><p>词法分析：手工书写</p><p>语法分析：递归下降</p><p>AST：有，遍历AST生成IR</p><p>IR：三地址码、SSA、类LLVM的IR</p><p>总代码量：约10000行</p><p>优化：</p><ol><li>常量折叠</li><li>死代码删除</li><li>只读全局转常量</li><li>只写变量移除</li><li>去除无用分支</li><li>基本块合并</li><li>循环不变量外提（参考）</li><li>公共子表达式删除（参考）</li><li>局部数组传播</li><li>常量数组全局化</li></ol><p>主要参考：<a href="https://github.com/Forever518/Whitee"><em>北航 早安！白给人</em></a>and <em>《Efficient Construction of Static Single Assignment Form》</em></p><h2 id="二、词法分析"><a href="#二、词法分析" class="headerlink" title="二、词法分析"></a>二、词法分析</h2><p>定义了TokenInfo来代表每个token的类型，同时，还特别区分识别八进制、十进制、十六进制，与可能存在的溢出。</p><h2 id="三、语法分析"><a href="#三、语法分析" class="headerlink" title="三、语法分析"></a>三、语法分析</h2><p>首先，按照SysY的语法规则，定义了不同的节点类，并存在着继承关系</p><p><img src="https://fastly.jsdelivr.net/gh/shenzuzhenwang/CDN/blog/complier1/1.png" alt="image-20220703120451370"></p><p>然后按照给定的语法，将会按照优先级，进行依次的递归下降分析，最后生成对应的AST节点</p><p>此外，还有symbolTable记录标识符名称，如函数名称，以及不同函数内的变量名称等</p><h2 id="四、IR生成"><a href="#四、IR生成" class="headerlink" title="四、IR生成"></a>四、IR生成</h2><p>IR的各类型节点继承图如下（类似LLVM的IR）</p><p><img src="https://fastly.jsdelivr.net/gh/shenzuzhenwang/CDN/blog/complier1/2.png" alt="image-20220703120434896"></p><p>遍历之前生成的AST。</p><ol><li><p>首先生成全局的变量GlobalValue与全局常量数组ConstantValue（全局常量直接替代）。</p></li><li><p>进入函数头，生成Function与入口BasicBlock，并记录函数参数ParameterValue。</p></li><li><p>blockToIr：之后进入函数体BLOCK，逐步分析，如果为局部变量，则定义VarDeclNode，并查看后面可能有的初始化值EXP；如果为语句，则</p></li><li><p>stmtToIr：判断语句的类型，ASSIGN则分析右值EXP；BLOCK则blockToIr；</p><p> IF与IF_ELSE则需要先分析条件conditionToIr，再生成每个可能的BasicBlock（包括ifStmt，elseStmt），并维护BasicBlock的前驱后继（ifStmt，elseStmt，endIf与当前的stmt，最后分析新生成的每个BasicBlock其中的语句stmtToIr；</p><p> WHILE先分析条件conditionToIr，再生成whileBody，whileJudge，whileEnd，preWhileBody等BasicBlock，并维护前驱后继，分析每个BasicBlock其中的语句stmtToIr，并记录循环深度</p><p> RETURN与BREAK则会直接改变WHILE中BasicBlock的前驱后继</p></li><li><p>conditionToIr：<strong>短路求值</strong>，依次递归分析LOrExpNode、LAndExpNode、EqExpNode（优先级依次递增），如果存在短路求值的情况，则会生成新的BasicBlock，并改变此BasicBlock的前驱后继，再继续分析conditionToIr</p></li><li><p>expToIr：分析不同情况的表达式，并将给表达式添加使用对象（之后会用）</p></li></ol><h2 id="五、SSA"><a href="#五、SSA" class="headerlink" title="五、SSA"></a>五、SSA</h2><p>SSA主要参考《Simple and Efficient Construction of Static Single Assignment Form》</p><p>对于每个基本块我们维护一个从每个源码变量到当前定义表达式的映射（map）。当对一个变量赋值时，我们记录 IR 的右边作为变量的当前定义。于是，当一个变量被读取时，我们查询它的当前定义</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">writeVariable(variable, block, value):currentDef[variable][block] ← valuereadVariable(variable, block):if currentDef[variable] contains block:# local value numberingreturn currentDef[variable][block]# global value numberingreturn readVariableRecursive(variable, block)局部值编号的实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在前驱块中查找一个值可能会导致进一步的递归查找。由于程序中有循环，可能导致无法终结的递归。因此在递归前，我们先创建没有操作数的 φ 函数并记录为基本块中的对应变量的当前定义。然后确定 φ 函数的操作数。如果递归查找回到了这个块中，这个 φ 函数将会提供一个定义并终止递归。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">readVariableRecursive(variable, block):if block not in sealedBlocks:  # 块不封闭，仅存在于循环体，此时可能前驱未加入完        val ← new Phi(block)        incompletePhis[block][variable] ← valelse if |block.preds| = 1:# 优化只有一个前驱的情况：不需要 phival ← readVariable(variable, block.preds[0])else:        # 如果有两个以上前驱块，用无操作数的 phi 破坏潜在的循环        val ← new Phi(block)        writeVariable(variable, block, val)        val ← addPhiOperands(variable, val)writeVariable(variable, block, val)return valaddPhiOperands(variable, phi):    # 从前驱中确定操作数    for pred in phi.block.preds:    # 递归向前驱块寻找同名变量的值，可能会由于循环，找到一样phi    phi.appendOperand(readVariable(variable, pred))    # 由于可能由于循环，phi的操作数的值为phi自己；或是两个操作数相同，此时需要去除phi    return tryRemoveTrivialPhi(phi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归查找可能会留下冗余的 φ 函数，当且仅当它仅仅多次引用它自己和另一个值 v。这样一个 φ 函数能被移除并且用 v 代替它。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tryRemoveTrivialPhi(phi):    same ← None    # 操作数为自己和另一个值的时候，此phi可以用另一个值代替    for op in phi.operands:        if op = same || op = phi:        continue # 只有一个唯一值或引用自己        if same 6= None:        return phi # The phi merges at least two values: not trivial        same ← op    if same = None:    same ← new Undef() # phi 不可达或在开始块中    users ← phi.users.remove(phi) # 找出所有以这个 phi 为操作数的 φ 函数，除了它本身    phi.replaceBy(same) # 将所有用到 phi 的地方替代为 same 并移除 phi        # 尝试去递归移除用到 phi 的 φ 函数，因为它可能变得不重要（trivial）    for use in users:        if use is a Phi:        tryRemoveTrivialPhi(use)    return same<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个基本块没有前驱会被添加进来，我们称这样的基本块是密封的（sealed）。只有被填满的块有后继，前驱总是被填满。注意一个密封的块不一定被填满。直观的说，一个被填满的块包含它所有的指令（instructions）和能给后继提供的变量定义。相反，当前驱都是已知时，一个被密封的块可以在它的前驱查询变量定义。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">sealBlock(block):# 在前驱查询变量定义 加入变量的phi可能值    for variable in incompletePhis[block]:    addPhiOperands(variable, incompletePhis[block][variable])    sealedBlocks.add(block)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、IR优化"><a href="#六、IR优化" class="headerlink" title="六、IR优化"></a>六、IR优化</h2><h3 id="1-只读全局变量转为常数"><a href="#1-只读全局变量转为常数" class="headerlink" title="1. 只读全局变量转为常数"></a>1. 只读全局变量转为常数</h3><p>先查看变量是否有被写入的可能，如果有使用store指令，或者全局数组被当做参数，则有写入的可能。</p><p>如果此全局变量没有被写入的可能，则将全局变量转换为常数，或者const array</p><h3 id="2-常量折叠"><a href="#2-常量折叠" class="headerlink" title="2. 常量折叠"></a>2. 常量折叠</h3><p>遍历每条IR，在二元操作中，如果两方都是常数，则直接得出结果；如果一方为特殊的常数（如0、1、-1等），则也可得出结果，或优化至仅一个操作数</p><p>在一元操作中，可以将多个一元操作简化。</p><p>在load操作中，可以直接提取const array中的常数。</p><h3 id="3-局部数组传播"><a href="#3-局部数组传播" class="headerlink" title="3. 局部数组传播"></a>3. 局部数组传播</h3><p>记录数组被执行的操作，如果是store指令，且offset为常数，则记录目前对应位置的值；如果是load指令，且offset为常数，则查看有没有记录的值，有的话直接提取为常数；如果是其他操作，则清除之前记录的值（因为不知道数组是否改变，或改变了哪里）。</p><h3 id="4-只写变量清除"><a href="#4-只写变量清除" class="headerlink" title="4. 只写变量清除"></a>4. 只写变量清除</h3><p>记录局部数组和全局变量被执行的操作，如果只有store而没有load，则去除此变量</p><h3 id="5-局部数组全局化"><a href="#5-局部数组全局化" class="headerlink" title="5. 局部数组全局化"></a>5. 局部数组全局化</h3><p>记录局部数组被执行的操作，如果其中只有store和load操作，且store的操作只有一次，offset和value均为常数，则将此局部数组转为const array</p><h3 id="6-循环不变量移除（参考）"><a href="#6-循环不变量移除（参考）" class="headerlink" title="6. 循环不变量移除（参考）"></a>6. 循环不变量移除（参考）</h3><p>对于每个函数，创建支配树，找到循环块，并找到block中的不动代码，最后插入有着循环不变量的块</p><h3 id="7-公共子表达式删除"><a href="#7-公共子表达式删除" class="headerlink" title="7. 公共子表达式删除"></a>7. 公共子表达式删除</h3><p>对比两个指令的表达式是否相同（hashCode），以及对比相同表达式的两个值相同（equals），如果都一样，则变量直接替代即可</p><h3 id="8-去除无用分支"><a href="#8-去除无用分支" class="headerlink" title="8. 去除无用分支"></a>8. 去除无用分支</h3><p>当分支条件为常数时，去除其中无用的分支块</p><h3 id="9-基本块合并"><a href="#9-基本块合并" class="headerlink" title="9. 基本块合并"></a>9. 基本块合并</h3><p>当某个基本块只有一个后继块时，可以去除掉跳转指令，并将后继块的phi指令移到此块，将两个块合并</p><h3 id="10-死代码删除"><a href="#10-死代码删除" class="headerlink" title="10. 死代码删除"></a>10. 死代码删除</h3><p>记录每个指令被使用的情况。</p><ol><li>去除不被调用的函数（除main函数）</li><li>去除不被使用的全局变量</li><li>去除不用的块，先构建块的后继树，如果某个块没在后继树中，则此块不被使用</li><li>去除块不用的指令，如，有结果指令，但结果不被使用；调用的函数返回值不被使用，且函数无副作用（修改了自己范围之外的资源）</li></ol><h3 id="11-基于图着色的寄存器分配（参考）"><a href="#11-基于图着色的寄存器分配（参考）" class="headerlink" title="11. 基于图着色的寄存器分配（参考）"></a>11. 基于图着色的寄存器分配（参考）</h3><p>构建冲突图，标记每个变量活跃的时间，遍历每条指令，如果存在活跃值冲突，则加入冲突图表</p><p>最后分配物理寄存器，如果寄存器不足，无法解决冲突，则选取权重最小的变量，放入内存中，再次重新分配寄存器</p><h2 id="七、汇编指令生成"><a href="#七、汇编指令生成" class="headerlink" title="七、汇编指令生成"></a>七、汇编指令生成</h2><p><img src="https://fastly.jsdelivr.net/gh/shenzuzhenwang/CDN/blog/complier1/3.png" alt="image-20220703135533047"></p><ol><li><p>首先，将全局变量放入.data中</p></li><li><p>之后，处理每个函数，加载形参（前四个在寄存器，四个之后放入图着色分配的寄存器），记录函数的返回地址，并分配栈上的空间，然后将函数的basicblock转换为汇编bbToMachineBB，此外，要向每个块前加label，每800指令，或在块的最后，加载一次全局变量</p></li><li><p>bbToMachineBB：</p><p> RET：保存返回值至R0，sp释放栈</p><p> BR：先进行比较，之后按比较进行跳转</p><p> JMP：直接跳转即可</p><p> INVOKE：先进行函数调用前的操作，传递参数，然后跳转至目标函数，最后重建上下文，记录返回的值</p><p> UNARY：执行取负（0-x）和取反（cmp值与0，相等则变为1，否则变为0）</p><p> BINARY：取余需要，先进行除法，在对结果进行三元乘减；比较指令需要通过mov指令加条件得到；乘除操作两个操作数需要均为寄存器；其余操作一个数可为立即数</p><p> CMP：通过mov指令加条件得到</p><p> LOAD：全局变量，基地址与偏移量已知，直接加载；局部数组，先计算相对sp偏移量，再进行加载</p><p> STORE：与LOAD类似</p><p> PHI：将phi的值移入对应的寄存器</p></li><li><p>立即数：先判断立即数是否合法，不合法需要mov</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Complier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>self-introduction</title>
      <link href="/2022-08-04-self-introduction/"/>
      <url>/2022-08-04-self-introduction/</url>
      
        <content type="html"><![CDATA[<p>在下shenzu，蒟蒻一名。</p>]]></content>
      
      
      <categories>
          
          <category> 个人介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蒟蒻 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
